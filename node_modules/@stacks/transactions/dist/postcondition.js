"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postConditionModeFrom = exports.postConditionToHex = exports.postConditionToWire = void 0;
const constants_1 = require("./constants");
const wire_1 = require("./wire");
const FUNGIBLE_COMPARATOR_MAPPING = {
    eq: constants_1.FungibleConditionCode.Equal,
    gt: constants_1.FungibleConditionCode.Greater,
    lt: constants_1.FungibleConditionCode.Less,
    gte: constants_1.FungibleConditionCode.GreaterEqual,
    lte: constants_1.FungibleConditionCode.LessEqual,
};
const NON_FUNGIBLE_COMPARATOR_MAPPING = {
    sent: constants_1.NonFungibleConditionCode.Sends,
    'not-sent': constants_1.NonFungibleConditionCode.DoesNotSend,
};
function postConditionToWire(postcondition) {
    switch (postcondition.type) {
        case 'stx-postcondition':
            return {
                type: wire_1.StacksWireType.PostCondition,
                conditionType: constants_1.PostConditionType.STX,
                principal: postcondition.address === 'origin'
                    ? { type: wire_1.StacksWireType.Principal, prefix: constants_1.PostConditionPrincipalId.Origin }
                    : (0, wire_1.parsePrincipalString)(postcondition.address),
                conditionCode: FUNGIBLE_COMPARATOR_MAPPING[postcondition.condition],
                amount: BigInt(postcondition.amount),
            };
        case 'ft-postcondition':
            return {
                type: wire_1.StacksWireType.PostCondition,
                conditionType: constants_1.PostConditionType.Fungible,
                principal: postcondition.address === 'origin'
                    ? { type: wire_1.StacksWireType.Principal, prefix: constants_1.PostConditionPrincipalId.Origin }
                    : (0, wire_1.parsePrincipalString)(postcondition.address),
                conditionCode: FUNGIBLE_COMPARATOR_MAPPING[postcondition.condition],
                amount: BigInt(postcondition.amount),
                asset: (0, wire_1.parseAssetString)(postcondition.asset),
            };
        case 'nft-postcondition':
            return {
                type: wire_1.StacksWireType.PostCondition,
                conditionType: constants_1.PostConditionType.NonFungible,
                principal: postcondition.address === 'origin'
                    ? { type: wire_1.StacksWireType.Principal, prefix: constants_1.PostConditionPrincipalId.Origin }
                    : (0, wire_1.parsePrincipalString)(postcondition.address),
                conditionCode: NON_FUNGIBLE_COMPARATOR_MAPPING[postcondition.condition],
                asset: (0, wire_1.parseAssetString)(postcondition.asset),
                assetName: postcondition.assetId,
            };
        default:
            throw new Error('Invalid post condition type');
    }
}
exports.postConditionToWire = postConditionToWire;
function postConditionToHex(postcondition) {
    const wire = postConditionToWire(postcondition);
    return (0, wire_1.serializePostConditionWire)(wire);
}
exports.postConditionToHex = postConditionToHex;
function postConditionModeFrom(mode) {
    if (typeof mode === 'number')
        return mode;
    if (mode === 'allow')
        return constants_1.PostConditionMode.Allow;
    if (mode === 'deny')
        return constants_1.PostConditionMode.Deny;
    throw new Error(`Invalid post condition mode: ${mode}`);
}
exports.postConditionModeFrom = postConditionModeFrom;
//# sourceMappingURL=postcondition.js.map