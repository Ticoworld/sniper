import { FungibleConditionCode, NonFungibleConditionCode, PostConditionMode, PostConditionPrincipalId, PostConditionType, } from './constants';
import { StacksWireType, parseAssetString, parsePrincipalString, serializePostConditionWire, } from './wire';
const FUNGIBLE_COMPARATOR_MAPPING = {
    eq: FungibleConditionCode.Equal,
    gt: FungibleConditionCode.Greater,
    lt: FungibleConditionCode.Less,
    gte: FungibleConditionCode.GreaterEqual,
    lte: FungibleConditionCode.LessEqual,
};
const NON_FUNGIBLE_COMPARATOR_MAPPING = {
    sent: NonFungibleConditionCode.Sends,
    'not-sent': NonFungibleConditionCode.DoesNotSend,
};
export function postConditionToWire(postcondition) {
    switch (postcondition.type) {
        case 'stx-postcondition':
            return {
                type: StacksWireType.PostCondition,
                conditionType: PostConditionType.STX,
                principal: postcondition.address === 'origin'
                    ? { type: StacksWireType.Principal, prefix: PostConditionPrincipalId.Origin }
                    : parsePrincipalString(postcondition.address),
                conditionCode: FUNGIBLE_COMPARATOR_MAPPING[postcondition.condition],
                amount: BigInt(postcondition.amount),
            };
        case 'ft-postcondition':
            return {
                type: StacksWireType.PostCondition,
                conditionType: PostConditionType.Fungible,
                principal: postcondition.address === 'origin'
                    ? { type: StacksWireType.Principal, prefix: PostConditionPrincipalId.Origin }
                    : parsePrincipalString(postcondition.address),
                conditionCode: FUNGIBLE_COMPARATOR_MAPPING[postcondition.condition],
                amount: BigInt(postcondition.amount),
                asset: parseAssetString(postcondition.asset),
            };
        case 'nft-postcondition':
            return {
                type: StacksWireType.PostCondition,
                conditionType: PostConditionType.NonFungible,
                principal: postcondition.address === 'origin'
                    ? { type: StacksWireType.Principal, prefix: PostConditionPrincipalId.Origin }
                    : parsePrincipalString(postcondition.address),
                conditionCode: NON_FUNGIBLE_COMPARATOR_MAPPING[postcondition.condition],
                asset: parseAssetString(postcondition.asset),
                assetName: postcondition.assetId,
            };
        default:
            throw new Error('Invalid post condition type');
    }
}
export function postConditionToHex(postcondition) {
    const wire = postConditionToWire(postcondition);
    return serializePostConditionWire(wire);
}
export function postConditionModeFrom(mode) {
    if (typeof mode === 'number')
        return mode;
    if (mode === 'allow')
        return PostConditionMode.Allow;
    if (mode === 'deny')
        return PostConditionMode.Deny;
    throw new Error(`Invalid post condition mode: ${mode}`);
}
//# sourceMappingURL=postcondition.js.map